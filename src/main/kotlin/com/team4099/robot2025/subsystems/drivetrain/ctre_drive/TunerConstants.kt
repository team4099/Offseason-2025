package com.team4099.robot2025.subsystems.drivetrain.ctre_drive

import com.ctre.phoenix6.CANBus
import com.ctre.phoenix6.configs.CANcoderConfiguration
import com.ctre.phoenix6.configs.CurrentLimitsConfigs
import com.ctre.phoenix6.configs.MotorOutputConfigs
import com.ctre.phoenix6.configs.Pigeon2Configuration
import com.ctre.phoenix6.configs.Slot0Configs
import com.ctre.phoenix6.configs.TalonFXConfiguration
import com.ctre.phoenix6.hardware.CANcoder
import com.ctre.phoenix6.hardware.TalonFX
import com.ctre.phoenix6.signals.NeutralModeValue
import com.ctre.phoenix6.signals.StaticFeedforwardSignValue
import com.ctre.phoenix6.swerve.SwerveDrivetrain
import com.ctre.phoenix6.swerve.SwerveDrivetrainConstants
import com.ctre.phoenix6.swerve.SwerveModuleConstants
import com.ctre.phoenix6.swerve.SwerveModuleConstants.DriveMotorArrangement
import com.ctre.phoenix6.swerve.SwerveModuleConstants.SteerMotorArrangement
import com.ctre.phoenix6.swerve.SwerveModuleConstantsFactory
import com.team4099.robot2025.config.constants.Constants
import com.team4099.robot2025.config.constants.DrivetrainConstants
import edu.wpi.first.math.Matrix
import edu.wpi.first.math.numbers.N1
import edu.wpi.first.math.numbers.N3
import org.team4099.lib.units.LinearVelocity
import org.team4099.lib.units.base.Current
import org.team4099.lib.units.base.Length
import org.team4099.lib.units.base.amps
import org.team4099.lib.units.base.inAmperes
import org.team4099.lib.units.base.inMeters
import org.team4099.lib.units.base.inches
import org.team4099.lib.units.derived.Angle
import org.team4099.lib.units.derived.ElectricalPotential
import org.team4099.lib.units.derived.MomentOfInertia
import org.team4099.lib.units.derived.inKilogramsMeterSquared
import org.team4099.lib.units.derived.inRadians
import org.team4099.lib.units.derived.inRotations
import org.team4099.lib.units.derived.inVolts
import org.team4099.lib.units.derived.inVoltsPerMeters
import org.team4099.lib.units.derived.inVoltsPerMetersPerSecond
import org.team4099.lib.units.derived.inVoltsPerMetersPerSecondPerSecond
import org.team4099.lib.units.derived.inVoltsPerRadian
import org.team4099.lib.units.derived.inVoltsPerRadianPerSecond
import org.team4099.lib.units.derived.inVoltsPerRadianSeconds
import org.team4099.lib.units.derived.inVoltsPerRadiansPerSecond
import org.team4099.lib.units.derived.rotations
import org.team4099.lib.units.derived.volts
import org.team4099.lib.units.inMetersPerSecond

// Generated by the Tuner X Swerve Project Generator
// https://v6.docs.ctr-electronics.com/en/stable/docs/tuner/tuner-swerve/index.html
object TunerConstants {
  // Both sets of gains need to be tuned to your individual robot.
  // The steer motor uses any SwerveModule.SteerRequestType control request with the
  // output type specified by SwerveModuleConstants.SteerMotorClosedLoopOutput
  private val steerGains: Slot0Configs? =
    Slot0Configs()
      .withKP(DrivetrainConstants.PID.STEERING_KP.inVoltsPerRadian)
      .withKI(DrivetrainConstants.PID.STEERING_KI.inVoltsPerRadianSeconds)
      .withKD(DrivetrainConstants.PID.STEERING_KD.inVoltsPerRadianPerSecond)
      .withKV(DrivetrainConstants.PID.STEERING_KFF.inVoltsPerRadiansPerSecond)
      .withStaticFeedforwardSign(StaticFeedforwardSignValue.UseClosedLoopSign)

  // When using closed-loop control, the drive motor uses the control
  // output type specified by SwerveModuleConstants.DriveMotorClosedLoopOutput
  private val driveGains: Slot0Configs? =
    Slot0Configs()
      .withKP(DrivetrainConstants.PID.DRIVE_KP.inVoltsPerMetersPerSecond)
      .withKI(DrivetrainConstants.PID.DRIVE_KI.inVoltsPerMeters)
      .withKD(DrivetrainConstants.PID.DRIVE_KD.inVoltsPerMetersPerSecondPerSecond)
      .withKS(DrivetrainConstants.PID.DRIVE_KS.inVolts)
      .withKV(DrivetrainConstants.PID.DRIVE_KV.inVoltsPerMetersPerSecond)
      .withKA(DrivetrainConstants.PID.DRIVE_KA.inVoltsPerMetersPerSecondPerSecond)

  // The closed-loop output type to use for the steer motors;
  // This affects the PID/FF gains for the steer motors
  private val kSteerClosedLoopOutput = SwerveModuleConstants.ClosedLoopOutputType.Voltage

  // The closed-loop output type to use for the drive motors;
  // This affects the PID/FF gains for the drive motors
  private val kDriveClosedLoopOutput = SwerveModuleConstants.ClosedLoopOutputType.Voltage

  // The type of motor used for the drive motor
  private val kDriveMotorType = DriveMotorArrangement.TalonFX_Integrated

  // The type of motor used for the drive motor
  private val kSteerMotorType = SteerMotorArrangement.TalonFX_Integrated

  // The remote sensor feedback type to use for the steer motors;
  // When not Pro-licensed, Fused*/Sync* automatically fall back to Remote*
  private val kSteerFeedbackType = SwerveModuleConstants.SteerFeedbackType.FusedCANcoder

  // The stator current at which the wheels start to slip;
  // This needs to be tuned to your individual robot
  // TODO check this
  private val kSlipCurrent: Current = 120.amps // Units.Amps.of(120.0)

  // Initial configs for the drive and steer motors and the azimuth encoder; these cannot be null.
  // Some configs will be overwritten; check the `with*InitialConfigs()` API documentation.
  private val driveInitialConfigs =
    TalonFXConfiguration()
      .withCurrentLimits(
        CurrentLimitsConfigs()
          .withStatorCurrentLimit(DrivetrainConstants.DRIVE_STATOR_CURRENT_LIMIT.inAmperes)
          .withStatorCurrentLimitEnable(true)
          .withSupplyCurrentLimit(
            DrivetrainConstants.STEERING_SUPPLY_CURRENT_LIMIT.inAmperes
          )
          .withSupplyCurrentLimitEnable(true)
      )
  private val steerInitialConfigs: TalonFXConfiguration? =
    TalonFXConfiguration()
      .withCurrentLimits(
        CurrentLimitsConfigs() // Swerve azimuth does not require much torque output, so we
          // can set a relatively low
          // stator current limit to help avoid brownouts without impacting performance.
          .withStatorCurrentLimit(DrivetrainConstants.DRIVE_STATOR_CURRENT_LIMIT.inAmperes)
          .withStatorCurrentLimitEnable(true)
          .withSupplyCurrentLimit(
            DrivetrainConstants.STEERING_SUPPLY_CURRENT_LIMIT.inAmperes
          )
          .withSupplyCurrentLimitEnable(true)
      )
      // setting brake might be unneccessary but whatever
      .withMotorOutput(MotorOutputConfigs().withNeutralMode(NeutralModeValue.Brake))

  private val encoderInitialConfigs = CANcoderConfiguration()

  // Configs for the Pigeon 2; leave this null to skip applying Pigeon 2 configs
  private val pigeonConfigs: Pigeon2Configuration? = null

  // CAN bus that the devices are located on;
  // All swerve devices must share the same CAN bus
  val kCANBus: CANBus = CANBus(Constants.Universal.CANIVORE_NAME, "./logs/example.hoot")

  // Theoretical free speed (m/s) at 12 V applied output;
  // This needs to be tuned to your individual robot
  val kSpeedAt12Volts: LinearVelocity = DrivetrainConstants.DRIVE_SETPOINT_MAX

  // Every 1 rotation of the azimuth results in kCoupleRatio drive motor turns;
  // This may need to be tuned to your individual robot
  private const val kCoupleRatio = 3.125

  private const val kDriveGearRatio =
    1.0 / DrivetrainConstants.MK4_DRIVE_SENSOR_GEAR_RATIO // 5.902777777777778
  private const val kSteerGearRatioMK4N =
    1.0 / DrivetrainConstants.MK4N_STEERING_SENSOR_GEAR_RATIO // 18.75
  private const val kSteerGearRatioMK4I =
    1.0 / DrivetrainConstants.MK4I_STEERING_SENSOR_GEAR_RATIO // 21.4285714286
  private val kWheelRadius: Length = DrivetrainConstants.WHEEL_DIAMETER / 2

  private const val kInvertLeftSide = false
  private const val kInvertRightSide = true

  private const val kPigeonId = Constants.Gyro.PIGEON_2_ID

  // These are only used for simulation
  private val kSteerInertia: MomentOfInertia = DrivetrainConstants.DRIVE_WHEEL_INERTIA
  private val kDriveInertia: MomentOfInertia = DrivetrainConstants.DRIVE_WHEEL_INERTIA

  // Simulated voltage necessary to overcome friction
  private val kSteerFrictionVoltage: ElectricalPotential = 0.0.volts
  private val kDriveFrictionVoltage: ElectricalPotential = 0.0.volts

  val CTREDrivetrainConstants: SwerveDrivetrainConstants? =
    SwerveDrivetrainConstants()
      .withCANBusName(kCANBus.getName())
      .withPigeon2Id(kPigeonId)
      .withPigeon2Configs(pigeonConfigs)

  private val ConstantCreator:
    SwerveModuleConstantsFactory<
      TalonFXConfiguration?, TalonFXConfiguration?, CANcoderConfiguration?> =
      SwerveModuleConstantsFactory<
        TalonFXConfiguration?, TalonFXConfiguration?, CANcoderConfiguration?>()
        .withDriveMotorGearRatio(kDriveGearRatio)
        .withCouplingGearRatio(kCoupleRatio)
        .withWheelRadius(kWheelRadius.inMeters)
        .withSteerMotorGains(steerGains)
        .withDriveMotorGains(driveGains)
        .withSteerMotorClosedLoopOutput(kSteerClosedLoopOutput)
        .withDriveMotorClosedLoopOutput(kDriveClosedLoopOutput)
        .withSlipCurrent(kSlipCurrent.inAmperes)
        .withSpeedAt12Volts(kSpeedAt12Volts.inMetersPerSecond)
        .withDriveMotorType(kDriveMotorType)
        .withSteerMotorType(kSteerMotorType)
        .withFeedbackSource(kSteerFeedbackType)
        .withDriveMotorInitialConfigs(driveInitialConfigs)
        .withSteerMotorInitialConfigs(steerInitialConfigs)
        .withEncoderInitialConfigs(encoderInitialConfigs)
        .withSteerInertia(kSteerInertia.inKilogramsMeterSquared)
        .withDriveInertia(kDriveInertia.inKilogramsMeterSquared)
        .withSteerFrictionVoltage(kSteerFrictionVoltage.inVolts)
        .withDriveFrictionVoltage(kDriveFrictionVoltage.inVolts)

  // Front Left
  private const val kFrontLeftDriveMotorId = 17
  private const val kFrontLeftSteerMotorId = 21
  private const val kFrontLeftEncoderId = 15
  private val kFrontLeftEncoderOffset = 0.228759765625.rotations
  private const val kFrontLeftSteerMotorInverted = true
  private const val kFrontLeftEncoderInverted = false

  private val kFrontLeftXPos: Length = 11.625.inches
  private val kFrontLeftYPos: Length = 11.625.inches

  // Front Right
  private const val kFrontRightDriveMotorId = 12
  private const val kFrontRightSteerMotorId = 22
  private const val kFrontRightEncoderId = 16
  private val kFrontRightEncoderOffset = -0.832518.rotations
  private const val kFrontRightSteerMotorInverted = true
  private const val kFrontRightEncoderInverted = false

  private val kFrontRightXPos: Length = 11.625.inches
  private val kFrontRightYPos: Length = -11.625.inches

  // Back Left
  private const val kBackLeftDriveMotorId = 13
  private const val kBackLeftSteerMotorId = 23
  private const val kBackLeftEncoderId = 17
  private val kBackLeftEncoderOffset = -0.215087890625.rotations
  private const val kBackLeftSteerMotorInverted = true
  private const val kBackLeftEncoderInverted = false

  private val kBackLeftXPos: Length = -11.625.inches
  private val kBackLeftYPos: Length = 11.625.inches

  // Back Right
  private const val kBackRightDriveMotorId = 14
  private const val kBackRightSteerMotorId = 24
  private const val kBackRightEncoderId = 18
  private val kBackRightEncoderOffset = -0.382084.rotations // don't use units because we don't know conversions
  private const val kBackRightSteerMotorInverted = true
  private const val kBackRightEncoderInverted = false

  private val kBackRightXPos: Length = -11.625.inches
  private val kBackRightYPos: Length = -11.625.inches

  val FrontLeft:
    SwerveModuleConstants<TalonFXConfiguration?, TalonFXConfiguration?, CANcoderConfiguration?>? =
      ConstantCreator.withSteerMotorGearRatio(kSteerGearRatioMK4N)
        .createModuleConstants(
          kFrontLeftSteerMotorId,
          kFrontLeftDriveMotorId,
          kFrontLeftEncoderId,
          kFrontLeftEncoderOffset.inRotations,
          kFrontLeftXPos.inMeters,
          kFrontLeftYPos.inMeters,
          kInvertLeftSide,
          kFrontLeftSteerMotorInverted,
          kFrontLeftEncoderInverted
        )
  val FrontRight:
    SwerveModuleConstants<TalonFXConfiguration?, TalonFXConfiguration?, CANcoderConfiguration?>? =
      ConstantCreator.withSteerMotorGearRatio(kSteerGearRatioMK4N)
        .createModuleConstants(
          kFrontRightSteerMotorId,
          kFrontRightDriveMotorId,
          kFrontRightEncoderId,
          kFrontRightEncoderOffset.inRotations,
          kFrontRightXPos.inMeters,
          kFrontRightYPos.inMeters,
          kInvertRightSide,
          kFrontRightSteerMotorInverted,
          kFrontRightEncoderInverted
        )
  val BackLeft:
    SwerveModuleConstants<TalonFXConfiguration?, TalonFXConfiguration?, CANcoderConfiguration?>? =
      ConstantCreator.withSteerMotorGearRatio(kSteerGearRatioMK4N)
        .createModuleConstants(
          kBackLeftSteerMotorId,
          kBackLeftDriveMotorId,
          kBackLeftEncoderId,
          kBackLeftEncoderOffset.inRotations,
          kBackLeftXPos.inMeters,
          kBackLeftYPos.inMeters,
          kInvertLeftSide,
          kBackLeftSteerMotorInverted,
          kBackLeftEncoderInverted
        )
  val BackRight:
    SwerveModuleConstants<TalonFXConfiguration?, TalonFXConfiguration?, CANcoderConfiguration?>? =
      ConstantCreator.withSteerMotorGearRatio(kSteerGearRatioMK4N)
        .createModuleConstants(
          kBackRightSteerMotorId,
          kBackRightDriveMotorId,
          kBackRightEncoderId,
          kBackRightEncoderOffset.inRotations,
          kBackRightXPos.inMeters,
          kBackRightYPos.inMeters,
          kInvertRightSide,
          kBackRightSteerMotorInverted,
          kBackRightEncoderInverted
        )

  /**
   * Creates a CommandSwerveDrivetrain instance. This should only be called once in your robot
   * program.
   */
  fun createDrivetrain(): CommandSwerveDrive {
    return CommandSwerveDrive(CTREDrivetrainConstants!!, FrontLeft, FrontRight, BackLeft, BackRight)
  }

  /** Swerve Drive class utilizing CTR Electronics' Phoenix 6 API with the selected device types. */
  open class TunerSwerveDrivetrain : SwerveDrivetrain<TalonFX?, TalonFX?, CANcoder?> {
    /**
     * Constructs a CTRE SwerveDrivetrain using the specified constants.
     *
     * This constructs the underlying hardware devices, so users should not construct the devices
     * themselves. If they need the devices, they can access them through getters in the classes.
     *
     * @param drivetrainConstants Drivetrain-wide constants for the swerve drive
     * @param modules Constants for each specific module
     */
    constructor(
      drivetrainConstants: SwerveDrivetrainConstants,
      vararg modules: SwerveModuleConstants<*, *, *>?
    ) : super(
      DeviceConstructor { deviceId: Int, canbus: String? -> TalonFX(deviceId, canbus) },
      DeviceConstructor { deviceId: Int, canbus: String? -> TalonFX(deviceId, canbus) },
      DeviceConstructor { deviceId: Int, canbus: String? -> CANcoder(deviceId, canbus) },
      drivetrainConstants,
      *modules
    )

    /**
     * Constructs a CTRE SwerveDrivetrain using the specified constants.
     *
     * This constructs the underlying hardware devices, so users should not construct the devices
     * themselves. If they need the devices, they can access them through getters in the classes.
     *
     * @param drivetrainConstants Drivetrain-wide constants for the swerve drive
     * @param odometryUpdateFrequency The frequency to run the odometry loop. If unspecified or set
     * to 0 Hz, this is 250 Hz on CAN FD, and 100 Hz on CAN 2.0.
     * @param modules Constants for each specific module
     */
    constructor(
      drivetrainConstants: SwerveDrivetrainConstants,
      odometryUpdateFrequency: Double,
      vararg modules: SwerveModuleConstants<*, *, *>?
    ) : super(
      DeviceConstructor { deviceId: Int, canbus: String? -> TalonFX(deviceId, canbus) },
      DeviceConstructor { deviceId: Int, canbus: String? -> TalonFX(deviceId, canbus) },
      DeviceConstructor { deviceId: Int, canbus: String? -> CANcoder(deviceId, canbus) },
      drivetrainConstants,
      odometryUpdateFrequency,
      *modules
    )

    /**
     * Constructs a CTRE SwerveDrivetrain using the specified constants.
     *
     * This constructs the underlying hardware devices, so users should not construct the devices
     * themselves. If they need the devices, they can access them through getters in the classes.
     *
     * @param drivetrainConstants Drivetrain-wide constants for the swerve drive
     * @param odometryUpdateFrequency The frequency to run the odometry loop. If unspecified or set
     * to 0 Hz, this is 250 Hz on CAN FD, and 100 Hz on CAN 2.0.
     * @param odometryStandardDeviation The standard deviation for odometry calculation in the form
     * [x, y, theta]ᵀ, with units in meters and radians
     * @param visionStandardDeviation The standard deviation for vision calculation in the form [x,
     * y, theta]ᵀ, with units in meters and radians
     * @param modules Constants for each specific module
     */
    constructor(
      drivetrainConstants: SwerveDrivetrainConstants,
      odometryUpdateFrequency: Double,
      odometryStandardDeviation: Matrix<N3?, N1?>,
      visionStandardDeviation: Matrix<N3?, N1?>,
      vararg modules: SwerveModuleConstants<*, *, *>?
    ) : super(
      DeviceConstructor { deviceId: Int, canbus: String? -> TalonFX(deviceId, canbus) },
      DeviceConstructor { deviceId: Int, canbus: String? -> TalonFX(deviceId, canbus) },
      DeviceConstructor { deviceId: Int, canbus: String? -> CANcoder(deviceId, canbus) },
      drivetrainConstants,
      odometryUpdateFrequency,
      odometryStandardDeviation,
      visionStandardDeviation,
      *modules
    )
  }
}
